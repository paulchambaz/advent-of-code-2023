use std::env;
use std::process;
use std::fs;
use std::time::Instant;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} [path]", args[0]);
        process::exit(1);
    }

    let path = &args[1];
    let file = fs::read_to_string(path).expect("Error, could not read file");

    let start = Instant::now();

    let task_1 = task_1(file.clone());
    let task_2 = task_2(file);

    let duration = start.elapsed();

    println!("Task 1: {}", task_1);
    println!("Task 2: {}", task_2);
    println!("Time: {} Âµs", duration.as_micros());
}

fn integer_sqrt(n: i32) -> i32 {
    if n < 2 {
        return n;
    }

    // Rough approximation of sqrt(n)
    let mut x = n / 2;
    
    loop {
        let next_x = (x + n / x) / 2;
        if next_x >= x {
            return x;
        }
        x = next_x;
    }
}

fn find_roots(a: i32, b: i32, c: i32) -> i32 {
    let discriminant = b * b - 4 * a * c;
    let sqrt_discriminant = f64::sqrt(discriminant as f64);
    let sqrt_discriminant = integer_sqrt(discriminant);
    (b + sqrt_discriminant) / (2 * a)
}

fn count(time: i32, distance: i32) -> i32 {
    time - 2 * find_roots(1, -1 * time, distance) + 1
    // let time_float = time as f64;
    // let distance_float = distance as f64;
    // let start = (f64::ceil((time_float - f64::sqrt(time_float * time_float - 4.0 * distance_float)) / 2.0)) as u32;
    // time - 2 * start + 1
}

fn task_1(file: String) -> u32 {
    let mut lines = file.lines();
    let times: Vec<i32> = lines.next().expect("Missing line")
            .split_whitespace()
            .filter_map(|s| s.parse::<i32>().ok())
            .collect();

    let distances: Vec<i32> = lines.next().expect("Missing line")
            .split_whitespace()
            .filter_map(|s| s.parse::<i32>().ok())
            .collect();

    let prod: i32 = times.iter().zip(distances.iter())
          .map(|(&time, &distance)| count(time, distance))
          .product();

    prod as u32
}

fn task_2(file: String) -> u32 {
    let mut lines = file.lines();
    let time = lines.next().expect("Missing line")
        .chars().filter(|c| c.is_numeric()).collect::<String>()
        .parse::<f64>().expect("Could not parse string");

    let distance = lines.next().expect("Missing line")
        .chars().filter(|c| c.is_numeric()).collect::<String>()
        .parse::<f64>().expect("Could not parse string");

    let start = (f64::ceil((time - f64::sqrt(time * time - 4. * distance)) / 2.)) as u32;

    time as u32 - 2 * start + 1
}
